
#' Generate MAG and PAG
#' 
#' Randomly generate a MAG (maximal ancestral graph) and PAG (partial ancestral graph i.e., the essential ancestral graph).
#' The ancestral graphs are generated by first drawing a topologically ordered random DAG using `pcalg::randomDAG`.
#' Then potential latent nodes are found by identifying all confounders and source nodes.
#' Some fraction of these potential latent nodes are chosen as latent nodes.
#' The PAG is generated using `pcalg::dag2pag` and the MAG is generated from the PAG by looking at descendants in the DAG.
#' 
#' The adjacency matrices follow the convention in pcalg: 0 refers to no edge. 1 refers to circle edge mark.
#'  2 refers to an arrowhead and 3 refers to a tail. For example, `g[a, b] = 2` and `g[b, a] = 1`
#'  says that the edge is `a o-> b`.
#' 
#' @param size Number of nodes in the underlying causal DAG.
#' Note that this is not the number of nodes in the ancestral graphs.
#' @param prob Probability of an edge between two nodes in the causal DAG
#' @param L_fraction Fraction of source and confounding nodes in the underlying DAG
#' that should be chosen as latent nodes
#' @param seed Random seed. Defaults to `NA`
#' @returns Named list containing two elements, `mag` and `pag`.
#' `mag` is the adjacency matrix of the generated MAG.
#' `pag` is the corresponding essential ancestral graph (PAG) for `mag`.
#' @export
generate_mag_pag <- function(size, prob, L_fraction, seed=NA) {
    
    if (!is.na(seed)) {
        set.seed(seed)
    }
    
    # Generate a topologically ordered random DAG
    d <- pcalg::randomDAG(size, prob, lB=1, uB=1)
    d.amat <- as(d, "matrix")
    
    # Choose latent variables
    V <- d@nodes
    V.source <- names(which(colSums(d.amat) == 0))
    V.confounders <- names(which(rowSums(d.amat) == 2))
    L.candidates <- union(V.source, V.confounders)
    L.size <- as.integer(max(1, L_fraction * length(L.candidates)))
    if (L.size == length(L.candidates)) {
        # next
        L <- L.candidates
        # print(L.candidates)
        # print(L.size)
    }
    L <- sample(L.candidates, L.size)
    
    # Get MAG and PAG
    m <- edag2mag(d, V, L)
    p <- edag2pag(d, V, L)
    mag <- m@amat
    pag <- p@amat
    
    num_nodes <- nrow(mag)
    rownames(mag) <- colnames(mag) <- c(1:num_nodes)
    rownames(pag) <- colnames(pag) <- c(1:num_nodes)
    
    return(list("mag"=mag, "pag"=pag))
}






## dag 2 pag function 
## need g - graphnel object (your dag)
## g MUST be TOPOLOGICALLY ORDERED (that is no edges j -> i, where label j comes after  label i in V )
## V - list of names of variables in the dag
## L - list of names of latent variables to marginalize out
edag2pag <- function(g,V,L,verbose=FALSE)
{
  covar <- pcalg::trueCov(g)
  true.corr1 <- stats::cov2cor(covar)
  suffStat1 <- list(C = true.corr1, n = 10^9)
  
  indepTest1 <- pcalg::gaussCItest
  amat.dag <- as(g,"matrix")
  n <- nrow(amat.dag)
  rownames(amat.dag) <- colnames(amat.dag) <- c(1:n)
  
  L1 <- which(V%in%L)
  # ?dag2pag
  newpag <- pcalg::dag2pag(suffStat=suffStat1, indepTest=indepTest1, graph=g,L=L1,alpha = 0.9999,verbose=verbose)
  amat <- newpag@amat
  colnames(amat) <- rownames(amat) <- setdiff(V,L)
  #names.new <- setdiff(V,L)
  return(gplus1 <- new("fciAlgo", amat=amat))
  
  
}


## DAG to MAG function
## need g - graphnel object (your dag)
## g MUST be TOPOLOGICALLY ORDERED (that is no edges j -> i, where label j comes after  label i in V )
## V - list of names of variables in the dag
## L - list of names of latent variables to marginalize out
edag2mag <- function(g,V,L)
{
  covar <- pcalg::trueCov(g)
  true.corr1 <- stats::cov2cor(covar)
  suffStat1 <- list(C = true.corr1, n = 10^9)
  
  indepTest1 <- pcalg::gaussCItest
  amat.dag <- as(g,"matrix")
  n <- nrow(amat.dag)
  rownames(amat.dag) <- colnames(amat.dag) <- c(1:n)
  
  L1 <- which(V%in%L)
  
  newpag <- pcalg::dag2pag(suffStat=suffStat1, indepTest=indepTest1, graph=g,L=L1,alpha = 0.9999)
  amat <- newpag@amat
  
  names.new <- setdiff(V,L)
  
  ## find directions
  for ( i in 1: nrow(amat)){
    for (j in 1:nrow(amat)){
      if (amat[j,i]==1){
        old.name.i <- which(V == names.new[i])
        old.name.j <- which(V == names.new[j])
        if (old.name.i %in% pcalg::possDe(amat.dag,old.name.j,type="dag")){
          amat[j,i] <- 3
        }else{
          amat[j,i] <- 2
        }
      }
    }
  }
  colnames(amat) <- rownames(amat) <- setdiff(V,L)
  return(gplus1 <- new("fciAlgo", amat=amat))
}

